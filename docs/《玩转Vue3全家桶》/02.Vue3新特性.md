---
title: Vue3新特性
date: 2022-06-29 19:54:17
permalink: /pages/bd9212/
categories:
  - 《玩转 Vue 3 全家桶》
tags:
  - 
author: 
  name: Daotin
  link: https://github.com/Daotin
---
## Vue3新特性

### Vue2遗留问题

- 从开发维护的角度看，Vue 2 是使用 Flow.js 来做类型校验。但现在 Flow.js 已经停止维护了，整个社区都在全面使用 TypeScript 来构建基础库，Vue 团队也不例外。
- 从社区的二次开发难度来说，Vue 2 内部运行时，是直接执行浏览器 API 的。但这样就会在 Vue 2 的跨端方案中带来问题，要么直接进入 Vue 源码中，和 Vue 一起维护，比如 Vue 2 中你就能见到 Weex 的文件夹。
- 从我们普通开发者的角度来说，Vue 2 响应式并不是真正意义上的代理，而是基于 Object.defineProperty() 实现的。所以有很多缺陷，比如：新增数据就无法监听
- Option API 在组织代码较多组件的时候不易维护。当代码超过 300 行的时候，新增或者修改一个功能，就需要不停地在 data，methods 里跳转写代码，我称之为上下反复横跳。

### 从七个方面了解 Vue 3 新特性

**1、RFC 机制**

新的 RFC 机制也让我们所有人都可以参与 Vue 新语法的讨论。



**2、响应式系统**

Vue3使用Proxy对数据进行代理，而不是使用Object.defineProperty对数据进行拦截。

**Proxy 代表一种方向，就是框架会越来越多的拥抱浏览器的新特性。**



**3、自定义渲染器**

Vue 2 内部所有的模块都是揉在一起的，这样做会导致不好扩展的问题。

Vue 3 是怎么解决这个问题的呢？那就是**拆包**，使用最近流行的 **monorepo** 管理方式，响应式、编译和运行时全部独立了。

比如响应式独立了出来。而 Vue 2 的响应式只服务于 Vue，Vue 3 的响应式就和 Vue 解耦了，你甚至可以在 Node.js 和 React 中使用响应式。

渲染的逻辑也拆成了平台无关渲染逻辑和浏览器渲染 API 两部分 。那么，在你想使用 Vue 3 开发小程序、开发 canvas 小游戏以及开发客户端的时候，就不用全部 fork Vue 的代码，只需要实现平台的渲染逻辑就可以。



**4、全部模块使用 TypeScript 重构**

类型系统的好处：第一点是，类型系统带来了更方便的提示；第二点是，类型系统让代码更健壮。



**5、Composition API 组合语法**

Options Api缺点：

- 由于所有数据都挂载在 this 之上，因而 Options API 的写法对 TypeScript 的类型推导很不友好，并且这样也不好做 Tree-shaking 清理代码。
- 新增功能基本都得修改 data、method 等配置，并且代码上 300 行之后，会经常上下反复横跳，开发很痛苦。
- 代码不好复用，Vue 2 的组件很难抽离通用逻辑，只能使用 mixin，还会带来命名冲突的问题。

使用 Composition API 后，虽然看起来烦琐了一些，但是带来了诸多好处：

- 所有 API 都是 import 引入的。用到的功能都 import 进来，对 Tree-shaking 很友好，我的例子里没用到功能，打包的时候会被清理掉 ，减小包的大小。
- 不再上下反复横跳，我们可以把一个功能模块的 methods、data 都放在一起书写，维护更轻松。
- 代码方便复用，可以把一个功能所有的 methods、data 封装在一个独立的函数里，复用代码非常容易。
- Composotion API 新增的 return 等语句，在实际项目中使用使用`<script setup>`特性可以清除， 我们后续项目中都会用到这样的操作。

Composition API 的代码风格，看起来会特别清爽。



**6、新的组件**

Vue 3 还内置了 Fragment、Teleport 和 Suspense 三个新组件。

- Fragment: Vue 3 组件不再要求有一个唯一的根节点，清除了很多无用的占位 div。
- Teleport: 允许组件渲染在别的元素内，主要开发弹窗组件的时候特别有用。
- Suspense: 异步组件，更方便开发有异步请求的组件。



**7、新一代工程化工具 Vite**

webpack的缺陷：Webpack 等工程化工具的原理，就是根据你的 import 依赖逻辑，形成一个依赖图，然后调用对应的处理工具，把整个项目打包后，放在内存里再启动调试。由于要预打包，所以复杂项目的开发，启动调试环境需要 3 分钟都很常见，Vite 就是为了解决这个时间资源的消耗问题出现的。

下图展示了 Webpack 的工作原理，Webpack 要把所有路由的依赖打包后，才能开始调试。
![](../assets/Pasted%20image%2020220612165912.png)



现代浏览器已经默认支持了 ES6 的 import 语法，Vite 就是基于这个原理来实现的。具体来说，在调试环境下，我们不需要全部预打包，只是把你首页依赖的文件，依次通过网络请求去获取，整个开发体验得到巨大提升，做到了复杂项目的秒级调试和热更新。

下图所示的是 Vite 的工作原理，一开始就可以准备联调，然后根据首页的依赖模块，再去按需加载，这样启动调试所需要的资源会大大减少。
![](../assets/Pasted%20image%2020220612165937.png)



**Vue3新特性总结图**
![](../assets/Pasted%20image%2020220612170037.png)

